# name: test/sql/types/nested/map/map_upsert.test
# description: Test UPSERTS for maps
# group: [map]

statement ok
PRAGMA enable_verification

statement ok
CREATE TABLE t1 (i INT PRIMARY KEY, j MAP(INT, INT));

statement ok
INSERT INTO t1 VALUES (1, MAP([1,2],[1,2]));

# Basic MAP upsert
statement ok
INSERT INTO t1 VALUES (1, MAP([1,2,3], [1,2,3])) ON CONFLICT DO UPDATE SET j = excluded.j;

query I
SELECT j FROM t1
----
{1=1, 2=2, 3=3}

# Upsert with empty map
statement ok
INSERT INTO t1 VALUES (1, MAP()) ON CONFLICT DO UPDATE SET j = excluded.j;

query I
SELECT j FROM t1
----
{}

# Upsert with NULL
statement ok
INSERT INTO t1 VALUES (1, NULL) ON CONFLICT DO UPDATE SET j = excluded.j;

query I
SELECT j FROM t1
----
NULL

# Upserts within transaction
statement ok
INSERT INTO t1 VALUES (3, MAP([3, 4], [3, 4]));

statement ok
BEGIN TRANSACTION;

# Validate new value is reflected within transaction
statement ok
INSERT INTO t1 VALUES (3, MAP([3, 5, 7], [7, 5 ,3])) ON CONFLICT DO UPDATE SET j = excluded.j;

query I
SELECT j from t1 WHERE i = 3;
----
{3=7, 5=5, 7=3}

# Conflicting updates within a transaction take effect within transaction
statement ok
INSERT INTO t1 VALUES (3, MAP([3, 4, 5, 6], [6, 5, 4, 3])) ON CONFLICT DO UPDATE SET j = excluded.j;

query I
SELECT j from t1 WHERE i = 3;
----
{3=6, 4=5, 5=4, 6=3}

# Rollback is clean
statement ok
ROLLBACK;

query I
SELECT j from t1 WHERE i = 3;
----
{3=3, 4=4}

statement ok
BEGIN TRANSACTION;

statement ok
INSERT INTO t1 VALUES (3, MAP([3, 7], [7, 3])) ON CONFLICT DO UPDATE SET j = excluded.j;

statement ok
INSERT INTO t1 VALUES (3, MAP([3, 5, 7], [7, 5 ,3])) ON CONFLICT DO UPDATE SET j = excluded.j;

statement ok
COMMIT;

# Committed transaction is reflected
query I
SELECT j from t1 WHERE i = 3;
----
{3=7, 5=5, 7=3}